# DevOps <!-- omit from toc -->

- [Ansible](#ansible)
  - [Required Manual Setup](#required-manual-setup)
- [Docker](#docker)
  - [Docker Secrets](#docker-secrets)
- [Machine-Configs](#machine-configs)
  - [CoreOS Ignition](#coreos-ignition)
  - [Useful Links](#useful-links)
  - [Proxmox Auto-Generated Template](#proxmox-auto-generated-template)
  - [Raspberry Pi with OLED Screen](#raspberry-pi-with-oled-screen)

## Ansible

### Required Manual Setup

- Ansible manages each host with sudo, a specific account (listed in ansible-vault), and SSH key. Before Ansible can
  configure anything, sudo must be installed, the management account must be created, given the public key, and granted passwordless sudo.
  - Ensure sudo is installed
  - `useradd ${ansible_user}`
  - `mkdir -p /home/${ansible_user}/.ssh/ && echo ${ansible_key} > /home/${ansible_user}/.ssh/authorized_keys`
  - `echo "${ansible_user}  ALL=(ALL)  NOPASSWD: ALL" >> /etc/sudoers.d/${ansible_user}`
- The hostname isn't set by Ansible. It must be set manually with something similar to `sudo hostnamectl hostname
"${NewName}"`.

## Docker

Each product / service / stack is separated into their own folders. This provides a clean "stack" interface in portainer
and clean separation in the folder structure.

Environment variables should be set by Ansible so containers always have access to them.

### Docker Secrets

Secrets are stored in PLAIN TEXT in the ***nfssecrets*** environment variable.

Docker Compose secrets example:

```` yaml
services:
  MyContainer:
    environment:
      - ENV_VAR=/run/secrets/MySecret
    secrets:
      - MySecret

secrets:
  MySecret:
    file: ${nfssecrets}/MySecret
````

To fill out a new secret, these are useful commands (`printf` or `echo -n` are used because some images do not accept new lines in the secret file):

- `openssl rand -base64 20 > /mnt/dozer/devops/docker/secrets/MySecret`
- `printf "This is my new secret" > /mnt/dozer/devops/docker/secrets/MySecret`

## Machine-Configs

The primary operating system for the homelab is Fedora CoreOS. CoreOS is container-focussed, immutable, and consumes
very little resources. It's also very easy to provision with Ignition.

### CoreOS Ignition

CoreOS is initially provisioned with Ignition files, which are based on yaml-spec Butane configurations. Red Hat
provides software that builds Ignition files from Butane configurations. The easiest way to do this is with Docker.

To use a Butane Docker container to build an Ignition file, `cd` into the machine-configs folder and run `docker run -i
--rm -v $PWD/:/mnt quay.io/coreos/butane:release -pso /mnt/coreos-output.ign /mnt/coreos-input.yml`, changing the input
and output names accordingly.

Some notes on CoreOS configuration:

- selinux is disabled because it conflicts with docker builds and I don't know enough about it
- 51-rollout-wariness.toml sets update frequency - 0 is most eager, 1 is most conservative
- 55-updates-strategy.toml time is UTC - 09:00 is actually 02:00 or 03:00 (depending on DST)

### Useful Links

- [Producing Ignition Files](https://docs.fedoraproject.org/en-US/fedora-coreos/producing-ign/)
- [CoreOS Ignition Spec 1.4](https://coreos.github.io/butane/config-fcos-v1_4/)

### Proxmox Auto-Generated Template

The FCOS templates in Proxmox are generated by a weekly cron named ***pve-fcos-template*** (the `.sh` is stripped so
that cron `run-parts` works). This script pulls the latest Fedora CoreOS, configures a new VM (template), converts the
CoreOS qcow2 disk into a ZFS dataset, and attaches to the ***coreos.ign*** ignition file (snippet) that's used during
first-boot provisioning.

To use the template, create a full clone of the template (linked clones are untested). Modify the networking, disk size,
CPU, memory, and PCI devices as needed.

### Raspberry Pi with OLED Screen

Each Raspberry Pi in the rackmount cluster includes a tiny 128x32 OLED screen that can be useful for displaying diagnostic information or general system information. These screens are connected via i2c which needs to be explicitly enabled in the OS. [Raspberry Pis use device-tree](https://www.raspberrypi.com/documentation/computers/configuration.html#device-trees-overlays-and-parameters) for such things.

Fedora CoreOS is the OS of choice here because it's immutable and self-updating, meaning the base OS generally takes care of itself. [Fedora has official doc](https://docs.fedoraproject.org/en-US/fedora-coreos/provisioning-raspberry-pi4/#_installing_fcos_and_booting_via_u_boot) for provisioning CoreOS onto Raspberry Pis. I'm using the U-boot bootloader because it's faster to boot and device-tree works (it also works with EDK2, but it's slower). The instructions are listed out in the Fedora documentation, but for ease of use, I provision my SD cards from a Fedora (or any linux) host like so:

1. `mkdir -p /tmp/RPi4boot/boot/efi`
2. Download the proper dnf packages
   1. `podman run --rm -v /tmp/RPi4boot:/tmp/RPi4boot:z fedora:42 dnf download --resolve --releasever=42 --forcearch=aarch64 --destdir=/tmp/RPi4boot/ uboot-images-armv8 bcm283x-firmware bcm283x-overlays`
3. Extract the dnf packages and stage u-boot.bin
   1. `podman run --rm -v /tmp/RPi4boot:/tmp/RPi4boot:z fedora:42 /bin/bash -c 'dnf install -y cpio; for rpm in /tmp/RPi4boot/*rpm; do rpm2cpio $rpm | cpio -idv -D /tmp/RPi4boot/; done; mv /tmp/RPi4boot/usr/share/uboot/rpi_arm64/u-boot.bin /tmp/RPi4boot/boot/efi/rpi-u-boot.bin'`
4. Copy your config.ign to /tmp/RPi4boot
5. Modify `/tmp/RPi4boot/boot/efi/config.txt`
   1. Add or uncomment `dtparam=i2c_arm=on`
   2. Comment out other dtparams that are not needed (e.g. for cameras)
6. Confirm /dev/mmcblk0 is the correct disk, unmount any partitions, and create the disk
   1. `sudo podman run --pull=always --privileged --rm -v /dev:/dev -v /run/udev:/run/udev -v /tmp/RPi4boot:/tmp/RPi4boot -w /tmp/RPi4boot quay.io/coreos/coreos-installer:release install -a aarch64 -s stable -i config.ign --append-karg nomodeset /dev/mmcblk0`
7. Mount the ESP partition and copy RPi4boot EFI files to the SD card
   1. `sudo podman run --privileged -it --rm -v /dev:/dev -v /run/udev:/run/udev -v /tmp/RPi4boot:/tmp/RPi4boot fedora:42 bash`
      1. `dnf install -y util-linux jq rsync`
      2. `mkdir /tmp/FCOSEFIpart`
      3. `FCOSEFIPARTITION=$(lsblk /dev/mmcblk0 -J -oLABEL,PATH  | jq -r '.blockdevices[] | select(.label == "EFI-SYSTEM").path')`
      4. `mount $FCOSEFIPARTITION /tmp/FCOSEFIpart`
      5. `rsync -avh --ignore-existing /tmp/RPi4boot/boot/efi/ /tmp/FCOSEFIpart/`
      6. `umount $FCOSEFIPARTITION`

[Directions for setting up the OLED screens](https://github.com/UCTRONICS/U6143_ssd1306)

**NOTE**: OLED screens can and should be managed through containerization and not directly from the host. **TODO**: add documentation

Check i2c devices with:

- `lsmod | grep i2c_`
- `ls -l /sys/firmware/devicetree/base/soc | grep i2c`

For optional further proof / verification / troubleshooting:

- `sudo rpm-ostree install i2c-tools`
- Reboot the Pi
- `i2cdetect -l` - An **i2c-1** device indicates proper configuration, and there will likely also be an **i2c-20** or **i2c-21**
