# DevOps <!-- omit from toc -->

- [Ansible](#ansible)
  - [Required Manual Setup](#required-manual-setup)
- [Docker](#docker)
  - [Docker Secrets](#docker-secrets)
- [Machine-Configs](#machine-configs)
  - [CoreOS Ignition](#coreos-ignition)
  - [Useful Links](#useful-links)
  - [Proxmox Auto-Generated Template](#proxmox-auto-generated-template)
  - [Raspberry Pi with OLED Screen (i2c enablement) (UNFINISHED)](#raspberry-pi-with-oled-screen-i2c-enablement-unfinished)

## Ansible

### Required Manual Setup

- Ansible manages each host with sudo, a specific account (listed in ansible-vault), and SSH key. Before Ansible can
  configure anything, sudo must be installed, the management account must be created, given the public key, and granted passwordless sudo.
  - Ensure sudo is installed
  - `useradd ${ansible_user}`
  - `mkdir -p /home/${ansible_user}/.ssh/ && echo ${ansible_key} > /home/${ansible_user}/.ssh/authorized_keys`
  - `echo "${ansible_user}  ALL=(ALL)  NOPASSWD: ALL" >> /etc/sudoers.d/${ansible_user}`
- The hostname isn't set by Ansible. It must be set manually with something similar to `sudo hostnamectl hostname
"${NewName}"`.

## Docker

Each product / service / stack is separated into their own folders. This provides a clean "stack" interface in portainer
and clean separation in the folder structure.

Environment variables should be set by Ansible so containers always have access to them.

### Docker Secrets

Secrets are stored in PLAIN TEXT in the ***nfssecrets*** environment variable.

Docker Compose secrets example:

```` yaml
services:
  MyContainer:
    environment:
      - ENV_VAR=/run/secrets/MySecret
    secrets:
      - MySecret

secrets:
  MySecret:
    file: ${nfssecrets}/MySecret
````

To fill out a new secret, these are useful commands (`printf` or `echo -n` are used because some images do not accept new lines in the secret file):

- `openssl rand -base64 20 > /mnt/dozer/devops/docker/secrets/MySecret`
- `printf "This is my new secret" > /mnt/dozer/devops/docker/secrets/MySecret`

## Machine-Configs

The primary operating system for the homelab is Fedora CoreOS. CoreOS is container-focussed, immutable, and consumes
very little resources. It's also very easy to provision with Ignition.

### CoreOS Ignition

CoreOS is initially provisioned with Ignition files, which are based on yaml-spec Butane configurations. Red Hat
provides software that builds Ignition files from Butane configurations. The easiest way to do this is with Docker.

To use a Butane Docker container to build an Ignition file, `cd` into the machine-configs folder and run `docker run -i
--rm -v $PWD/:/mnt quay.io/coreos/butane:release -pso /mnt/coreos-output.ign /mnt/coreos-input.yml`, changing the input
and output names accordingly.

Some notes on CoreOS configuration:

- selinux is disabled because it conflicts with docker builds and I don't know enough about it
- 51-rollout-wariness.toml sets update frequency - 0 is most eager, 1 is most conservative
- 55-updates-strategy.toml time is UTC - 09:00 is actually 02:00 or 03:00 (depending on DST)

### Useful Links

- [Producing Ignition Files](https://docs.fedoraproject.org/en-US/fedora-coreos/producing-ign/)
- [CoreOS Ignition Spec 1.4](https://coreos.github.io/butane/config-fcos-v1_4/)

### Proxmox Auto-Generated Template

The FCOS templates in Proxmox are generated by a weekly cron named ***pve-fcos-template*** (the `.sh` is stripped so
that cron `run-parts` works). This script pulls the latest Fedora CoreOS, configures a new VM (template), converts the
CoreOS qcow2 disk into a ZFS dataset, and attaches to the ***coreos.ign*** ignition file (snippet) that's used during
first-boot provisioning.

To use the template, create a full clone of the template (linked clones are untested). Modify the networking, disk size,
CPU, memory, and PCI devices as needed.

### Raspberry Pi with OLED Screen (i2c enablement) (UNFINISHED)

i2c on the Raspberry Pi is enabled and exposed to the OS with device-tree.

[Good info on device
tree](https://www.raspberrypi.com/documentation/computers/configuration.html#device-trees-overlays-and-parameters)

[Setting up a CoreOS image for U-boot and Raspberry
Pi](https://docs.fedoraproject.org/en-US/fedora-coreos/provisioning-raspberry-pi4/#_installing_fcos_and_booting_via_u_boot)

[Directions for setting up the OLED screens](https://github.com/UCTRONICS/U6143_ssd1306)

When preparing the SD card:

- Download and extract the RPMs as listed in the web docs
- Customize RPi4boot/boot/efi/config.txt to change HDMI params and enable i2c
- Flash the SD card and copy EFI files to it (which will include the customizes config.txt)

Below is done from freshly installed CoreOS

- `sudo rpm-ostree install --apply-live i2c-tools`
- `lsmod | grep i2c_`
- `ls -l /sys/firmware/devicetree/base/soc`

The Pi may need to be rebooted before *i2cdetect* will find devices

Expect i2c-1 device at least (may also see 20 and 21)

`i2cdetect -l`

`sudo rpm-ostree install --apply-live make gcc`
